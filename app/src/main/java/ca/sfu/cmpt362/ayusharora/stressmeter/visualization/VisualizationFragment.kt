package ca.sfu.cmpt362.ayusharora.stressmeter.visualization

import android.os.Bundle
import android.view.Gravity
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.TableLayout
import android.widget.TableRow
import android.widget.TextView
import androidx.core.content.ContextCompat
import androidx.fragment.app.Fragment
import ca.sfu.cmpt362.ayusharora.stressmeter.R
import ca.sfu.cmpt362.ayusharora.stressmeter.databinding.FragmentVisualizationBinding
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import java.io.File

class VisualizationFragment : Fragment() {

    // Used the binding class given by the default code generated by android studio
    private var _binding: FragmentVisualizationBinding? = null
    private val binding get() = _binding!!

    // Added my own code for readForCsv() to the default onCreateView
    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View {

        _binding = FragmentVisualizationBinding.inflate(inflater, container, false)
        val root: View = binding.root

        CoroutineScope(Dispatchers.IO).launch{
            readFromCSV()
        }
        return root
    }

    // Default code generated by android studio
    override fun onDestroyView() {

        super.onDestroyView()
        _binding = null
    }

    // Used the basic java I/O classes for reading from a CSV file
    // It reads the entire file line by line, and then extracts the required information
    // from each line by using split()
    private suspend fun readFromCSV(){

        val file = File(requireContext().filesDir, "stress_level_data.csv")
        if (file.exists()){

            val lines = file.readLines()
            for (line in lines){
                val parts = line.split(",")
                val timestamp = parts[0]
                val stressLevel = parts[1]
                withContext(Dispatchers.Main) {
                    addToTable(timestamp, stressLevel)
                }
            }
        }
    }

    // Learnt using a tableView in android studio from web
    // This helper method creates a new row, adds two textViews corresponding to
    // time and stress level and adds the row to the table with proper formatting
    private fun addToTable(timestamp: String, stressLevel: String){

        val summaryTable: TableLayout = binding.visualizationTablelayout
        val newRow = TableRow(requireContext())

        val time = TextView(requireContext())
        time.text = timestamp
        time.gravity = Gravity.CENTER
        time.background = ContextCompat.getDrawable(requireContext(), R.drawable.cell_border)

        val stress = TextView(requireContext())
        stress.text = stressLevel
        stress.gravity = Gravity.CENTER
        stress.background = ContextCompat.getDrawable(requireContext(), R.drawable.cell_border)

        newRow.addView(time)
        newRow.addView(stress)
        summaryTable.addView(newRow)

        // Got these two lines from chatGPT for formatting my table elements (arranging them in the centre of cell).
        time.layoutParams = TableRow.LayoutParams(0, TableRow.LayoutParams.WRAP_CONTENT, 1f)
        stress.layoutParams = TableRow.LayoutParams(0, TableRow.LayoutParams.WRAP_CONTENT, 1f)

    }
}