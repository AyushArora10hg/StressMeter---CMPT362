package ca.sfu.cmpt362.ayusharora.stressmeter.visualization

import android.os.Bundle
import android.view.Gravity
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.TableLayout
import android.widget.TableRow
import android.widget.TextView
import androidx.core.content.ContextCompat
import androidx.fragment.app.Fragment
import androidx.lifecycle.ViewModelProvider
import ca.sfu.cmpt362.ayusharora.stressmeter.R
import ca.sfu.cmpt362.ayusharora.stressmeter.databinding.FragmentVisualizationBinding
import com.anychart.AnyChart
import com.anychart.chart.common.dataentry.ValueDataEntry
import com.anychart.charts.Cartesian
import com.anychart.data.Set
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import java.io.File

class VisualizationFragment : Fragment() {

    // Used the binding class given by the default code generated by android studio
    private var _binding: FragmentVisualizationBinding? = null
    private val binding get() = _binding!!

    private lateinit var visualizationViewModel: VisualizationViewModel

    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View {
        _binding = FragmentVisualizationBinding.inflate(inflater, container, false)
        visualizationViewModel = ViewModelProvider(this)[VisualizationViewModel::class.java]
        return binding.root
    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)

        if (!visualizationViewModel.dataLoaded) {
            CoroutineScope(Dispatchers.IO).launch {
                readFromCSV()
                withContext(Dispatchers.Main) {
                    setupChart()
                    visualizationViewModel.dataLoaded = true
                }
            }
        } else {
            setupChart()
            for (row in visualizationViewModel.tableRows) {
                addToTable(row.first, row.second)
            }
        }
    }
    override fun onDestroyView() {
        super.onDestroyView()
        _binding = null
    }

    private suspend fun readFromCSV() {

        val file = File(requireContext().filesDir, "stress_level_data.csv")
        if (file.exists()){
            val lines = file.readLines()
            var instance = 0
            for (line in lines){
                val parts = line.split(",")
                val timestamp = parts[0].trim()
                val stressLevel = parts[1].trim().toInt()
                visualizationViewModel.chartData.add(ValueDataEntry(instance, stressLevel))
                visualizationViewModel.tableRows.add(Pair(timestamp, stressLevel.toString()))
                instance++

            }
            withContext(Dispatchers.Main) {
                for (row in visualizationViewModel.tableRows) {
                    addToTable(row.first, row.second)
                }
            }
        }
    }

    private fun setupChart() {

        val cartesian: Cartesian = AnyChart.line()
        val dataSet = Set.instantiate()
        dataSet.data(visualizationViewModel.chartData)

        val series = cartesian.line(dataSet.mapAs("{ x: 'x', value: 'value' }"))
        series.name("Stress Level")
        series.markers(true)
        series.markers()
            .type(com.anychart.enums.MarkerType.CIRCLE)
            .size(4)
            .fill("#FF5722")

        cartesian.title("Stress Level Over Time")
        cartesian.xAxis(0).title("Instance")
        cartesian.yAxis(0).title("Stress Level")

        cartesian.yScale().minimum(0.0)
        cartesian.yScale().maximum(16.0)

        cartesian.tooltip().enabled(true)

        binding.visualizationGraph.setChart(cartesian)
    }

    // Learnt using a tableView in android studio from web
    // This helper method creates a new row, adds two textViews corresponding to
    // time and stress level and adds the row to the table with proper formatting
    private fun addToTable(timestamp: String, stressLevel: String) {

        val summaryTable: TableLayout = binding.visualizationTablelayout
        val newRow = TableRow(requireContext())

        val time = TextView(requireContext())
        time.text = timestamp
        time.gravity = Gravity.CENTER
        time.background = ContextCompat.getDrawable(requireContext(), R.drawable.cell_border)

        val stress = TextView(requireContext())
        stress.text = stressLevel
        stress.gravity = Gravity.CENTER
        stress.background = ContextCompat.getDrawable(requireContext(), R.drawable.cell_border)

        newRow.addView(time)
        newRow.addView(stress)
        summaryTable.addView(newRow)

        // Got these two lines from chatGPT for formatting my table elements (arranging them in the centre of cell).
        time.layoutParams = TableRow.LayoutParams(0, TableRow.LayoutParams.WRAP_CONTENT, 1f)
        stress.layoutParams = TableRow.LayoutParams(0, TableRow.LayoutParams.WRAP_CONTENT, 1f)

    }
}